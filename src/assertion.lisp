;;;; assertion.lisp — Assertion for Confidence

;;;; Confidence (https://github.com/melusina-org/cl-confidence)
;;;; This file is part of Confidence.
;;;;
;;;; Copyright © 2019–2024 Michaël Le Barbier
;;;; All rights reserved.

;;;; This file must be used under the terms of the MIT License.
;;;; This source file is licensed as described in the file LICENSE, which
;;;; you should have received as part of this distribution. The terms
;;;; are also available at https://opensource.org/licenses/MIT

(in-package #:org.melusina.confidence)

;;;;
;;;; DEFINE-ASSERTION Macro
;;;;

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun set-assertion-properties (name lambda-list)
    "Set assertion properties on symbol NAME."
    (setf (get name :org.melusina.confidence/assertion) t)
    (setf (get name :org.melusina.confidence/lambda-list) lambda-list)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun parse-assertion-forms (name forms)
    "Parse assertion FORMS for assertion NAME.
It returns the DOCSTRING, the REPORT function, the list of DECLARATIONS
and remaining FORMS as multiple values."
    (declare (optimize (debug 3)))
    (check-type name symbol)
    (labels ((docstring-p (forms)
	       (and (> (length forms) 1) (stringp (first forms))))
	     (report-p (forms)
	       (and (eq :report (first forms)) (second forms)))
	     (list-report-p (forms)
	       (and (>= (length forms) 1) (listp (first forms)) (eq :report (first (first forms)))))
	     (read-docstring (forms)
               (if (docstring-p forms)
		   (read-report (first forms) (rest forms))
		   (read-report (autogenerated-docstring) forms)))
	     (read-report (docstring forms)
	       (cond
		 ((report-p forms)
		  (read-declarations docstring (second forms) (cddr forms)))
		 ((eq :report (first forms))
		  (error "The assertion definition ~A announces a :REPORT which is not provided."
			 (symbol-name name)))
		 ((list-report-p forms)
		  (warn "Obsolete :REPORT clause in DEFINE-ASSERTION.
The :REPORT clause should not be enclosed in a list.")
		  (read-declarations docstring (second (first forms)) (rest forms)))
		 (t
		  (read-declarations docstring docstring forms))))
	     (read-declarations (docstring report forms)
	       (loop :for iterator :on forms
		     :for form = (first iterator)
		     :while (and (listp form) (eq (first form) 'declare))
		     :collect form :into declarations
		     :finally (return (values docstring report declarations iterator))))
	     (autogenerated-docstring ()
	       (with-output-to-string (assertion-documentation)
		 (format assertion-documentation
			 "The assertion ~A is defined by the body forms~%~%"
			 (symbol-name name))
		 (dolist (form forms)
		   (format assertion-documentation "~&  ~S" form))
		 (format assertion-documentation
			 "~&~%This documentation string has been autogenerated."))))
      (read-docstring (alexandria:ensure-list forms)))))

(defun failwith-assertion-report (report)
  (let ((description
	  (etypecase report
	    (string
	     report)
	    (function
	     (with-output-to-string (buffer) (funcall report buffer))))))
    (values nil description)))

(declaim (inline failwith-assertion-report))

(defmacro define-assertion (name lambda-list &body body)
  "Define an assertion function NAME, accepting LAMBDA-LIST and evaluating BODY.
The BODY is interpreted as computing a generalised boolean value, which
determines if the assertion is a success or failure. When it is a success,
a single value T is returned. When it is a failure, two values NIL and
a descriptive string are returned.

The NAME must start with ASSERT-, ASSERT<, ASSERT> or ASSERT=.

When the first BODY form is a string, this string is used as a docstring for
the function NAME.  If no report function has been provided, a report function
constantly printing the docstring is supplied.

When the next BODY form starts with the keyword :REPORT, then the rest of that
form must be function of a STREAM.  This function is then used to generate an
informational message when reporting the corresponding error condition. This
allows to add dynamic context to this informational messsage, like the value
of some variables. (That syntax is reminesccent of RESTART-CASE.)"
  (multiple-value-bind (docstring report declarations forms) (parse-assertion-forms name body)
    (let ((body-forms
	    (if (>= 1 (length forms))
		(first forms)
		(cons 'progn forms)))
	  (declaration-forms
	    (cons '(declare (optimize (safety 3) (debug 3))) declarations)))
      (set-assertion-properties name lambda-list)
      `(prog1
	   (defun ,name ,lambda-list
	     ,docstring
	     ,@declaration-forms
	     (if ,body-forms t (failwith-assertion-report ,report)))
	 (set-assertion-properties ',name ',lambda-list)))))


;;;;
;;;; List assertions
;;;;

(defun list-assertions (&optional package-designator)
  "List assertions exported by PACKAGE-DESIGNATOR."
  (loop :for s :being :the :external-symbols :of (find-package package-designator)
	:when (get s :org.melusina.confidence/assertion)
	:collect s))

;;;;
;;;; Basic Assertions
;;;;

(define-assertion assert-t (expr)
  "Assert that EXPR is T.
This does not compare EXPR to T as a generalised boolean, cf. ASSERT-T*."
  (eq t expr))

(define-assertion assert-t* (expr)
  "Assert that EXPR is true as a generalised boolean."
  expr)

(define-assertion assert-nil (expr)
  "Assert that EXPR is NIL."
  (eq nil expr))

(define-assertion assert-type (expr type)
  "Assert that EXPR evaluates to a value of type TYPE."
  :report
  (lambda (stream)
    (format stream
	    #.(concatenate
	       'string
	       "~%~%The value yielded by EXPR is~%~%  ~S~&~%"
	       "and is of type~%~%  ~S~&~%"
	       "which is not a subtype of ~%~%  ~S~&~%")
	    expr
	    (type-of expr)
	    type))
  (typep expr type))

(define-assertion assert-eq (a b)
  "Assert that A and B satisfy the EQ predicate."
  (eq a b))

(define-assertion assert-eql (a b)
  "Assert that A and B satisfy the EQL predicate."
  (eql a b))

(define-assertion assert-equal (a b)
  "Assert that A and B satisfy the EQUAL predicate."
  (equal a b))

(define-assertion assert-equalp (a b)
  "Assert that A and B satisfy the EQUALP predicate."
  (equal a b))

(define-assertion assert= (a b)
  "Assert that A and B satisfy the = predicate."
  (= a b))

(define-assertion assert< (a b)
  "Assert that A and B satisfy the < predicate."
  (< a b))

(define-assertion assert> (a b)
  "Assert that A and B satisfy the > predicate."
  (> a b))

(define-assertion assert<= (a b)
  "Assert that A and B satisfy the <= predicate."
  (<= a b))

(define-assertion assert>= (a b)
  "Assert that A and B satisfy the >= predicate."
  (>= a b))


;;;;
;;;; Condition Assertion
;;;;

(defmacro assert-condition (form condition &optional slots &body body)
  "Assert that the evaluation of FORM signals a CONDITION.
It is possible to perform arbitrary checks on the condition by providing SLOTS,
which are bound to the generated condition slots as in WITH-SLOTS and the given
BODY yielding a boolean validating details of the assertion. When this boolean
is NIL, a string must be returned as second value to explain why the validation
failed."
  (let ((expected-condition-validation-form
	  (cond
	    ((and slots body)
	     `((with-slots ,slots expected-condition ,@body)))
	    (t
	     '((declare (ignore expected-condition))
	       t)))))
    `(handler-case
	 (let ((form-value ,form))
	   (values
	    nil
	    (with-output-to-string (assertion-documentation)
	      (format assertion-documentation
		      #.(stringcat
			 "The form ~S was expected to signal a condition ~S "
			 "but it yielded the value ~S instead.")
		      (quote ,form) (quote ,condition) form-value))))
       (,condition (expected-condition)
	 ,@expected-condition-validation-form)
       (t (unexpected-condition)
	 (values
	  nil
	  (with-output-to-string (assertion-documentation)
	    (format assertion-documentation
		    #.(stringcat
		       "The form ~S was expected to signal a ~S condition "
                       "but it yielded a ~S condition instead.~%~%  ~S")
		    (quote ,form)
		    (quote ,condition)
		    (type-of unexpected-condition)
		    unexpected-condition)))))))

(set-assertion-properties 'assert-condition '(form condition &optional slots &body body))


;;;;
;;;; Character Assertions
;;;;

(define-assertion assert-char= (character1 character2)
  "Assert that CHARACTER1 and CHARACTER2 satisfy the CHAR= predicate."
  (char= character1 character2))

(define-assertion assert-char-equal (character1 character2)
  "Assert that CHARACTER1 and CHARACTER2 satisfy the CHAR-EQUAL predicate."
  (char-equal character1 character2))

(define-assertion assert-char< (character1 character2)
  "Assert that CHARACTER1 and CHARACTER2 satisfy the CHAR< predicate."
  (char< character1 character2))

(define-assertion assert-char<= (character1 character2)
  "Assert that CHARACTER1 and CHARACTER2 satisfy the CHAR<= predicate."
  (char<= character1 character2))

(define-assertion assert-char> (character1 character2)
  "Assert that CHARACTER1 and CHARACTER2 satisfy the CHAR> predicate."
  (char> character1 character2))

(define-assertion assert-char>= (character1 character2)
  "Assert that CHARACTER1 and CHARACTER2 satisfy the CHAR>= predicate."
  (char>= character1 character2))


;;;;
;;;; String Assertions
;;;;

(defun report-string-comparison/unexpected-type (stream label object)
  (format stream "~&The parameter ~A is expected to have type STRING but actually has type ~A."
          label (type-of object)))

(defun report-string-comparison/details (stream comparison string1 string2)
  (declare (string string1 string2))
  (let ((length1
          (length string1))
        (length2
          (length string2))
        (first-difference
          (loop for i upto (1- (min (length string1) (length string2)))
                when (not (funcall comparison (char string1 i) (char string2 i)))
                return i
                finally (return i)))
        (predicate-description
          (ecase comparison
            (char=
             "equal to")
            (char-equal
             "equal to up to case difference")
            (char<
             "less than")
            (char<=
             "less than or equal to")
            (char>
             "greater than")
            (char>=
             "greater than or equal to"))))
    (cond
      ((= length1 length2 0)
       (format stream "~&Both strings STRING1 and STRING2 are empty."))
      ((= length1 0)
       (format stream "~&The string STRING1 is empty."))
      ((= length2 0)
       (format stream "~&The string STRING2 is empty."))
      ((= length1 length2 first-difference)
       (format stream
               "~&Every character of STRING1 is ~A the character of STRING2 at
the same index. Furthermore STRING1 and STRING2 have the same length ~A."
               predicate-description length1))
      ((and (< first-difference length1) (< first-difference length2))
       (format stream
               "~&Every character of STRING1 is ~A the character of STRING2 at
the same index upto index ~A. However this condition does not hold for characters
at position ~A, which are ~S and ~S."
               predicate-description first-difference first-difference
               (char string1 first-difference) (char string2 first-difference)))
      ((< first-difference length1)
       (format stream
               "~&Every character of STRING1 is ~A the character of STRING2 at
the same index. However STRING1 is longer than STRING2, these two strings
have length ~A and ~A respectively." 
               predicate-description length1 length2))
      ((< first-difference length2)
       (format stream
               "~&Every character of STRING1 is ~A the character of STRING2 at
the same index. However STRING1 is shorter than STRING2, these two strings
have length ~A and ~A respectively." 
               predicate-description length1 length2)))))

(defun make-report-string-comparison (comparison string1 string2)
  (lambda (stream)
    (unless (typep string1 'string)
      (report-string-comparison/unexpected-type stream 'string1 string1))
    (unless (typep string2 'string)
      (report-string-comparison/unexpected-type stream 'string2 string2))
    (when (and (typep string1 'string) (typep string2 'string))
      (report-string-comparison/details stream comparison string1 string2))))

(define-assertion assert-string-equal (string1 string2 &key (start1 0) end1 (start2 0) end2)
  "Assert that STRING1 and STRING2 satisfy the STRING-EQUAL predicate.
This assertion supports the same keyword parameters as STRING-EQUAL."
  :report (make-report-string-comparison 'char-equal string1 string2)
  (string-equal string1 string2 :start1 start1 :end1 end1 :start2 start2 :end2 end2))

(define-assertion assert-string= (string1 string2 &key (start1 0) end1 (start2 0) end2)
  "Assert that STRING1 and STRING2 satisfy the STRING= predicate.
This assertion supports the same keyword parameters as STRING=."
  :report (make-report-string-comparison 'char= string1 string2)
  (string= string1 string2 :start1 start1 :end1 end1 :start2 start2 :end2 end2))

(define-assertion assert-string< (string1 string2 &key (start1 0) end1 (start2 0) end2)
  "Assert that STRING1 and STRING2 satisfy the STRING< predicate.
This assertion supports the same keyword parameters as STRING<."
  :report (make-report-string-comparison 'char< string1 string2)
  (string< string1 string2 :start1 start1 :end1 end1 :start2 start2 :end2 end2))

(define-assertion assert-string> (string1 string2 &key (start1 0) end1 (start2 0) end2)
  "Assert that STRING1 and STRING2 satisfy the STRING> predicate.
This assertion supports the same keyword parameters as STRING>."
  :report (make-report-string-comparison 'char> string1 string2)
  (string> string1 string2 :start1 start1 :end1 end1 :start2 start2 :end2 end2))

(define-assertion assert-string<= (string1 string2 &key (start1 0) end1 (start2 0) end2)
  "Assert that STRING1 and STRING2 satisfy the STRING<= predicate.
This assertion supports the same keyword parameters as STRING<=."
  :report (make-report-string-comparison 'char<= string1 string2)
  (string<= string1 string2 :start1 start1 :end1 end1 :start2 start2 :end2 end2))

(define-assertion assert-string>= (string1 string2 &key (start1 0) end1 (start2 0) end2)
  "Assert that STRING1 and STRING2 satisfy the STRING>= predicate.
This assertion supports the same keyword parameters as STRING>=."
  :report (make-report-string-comparison 'char>= string1 string2)
  (string>= string1 string2 :start1 start1 :end1 end1 :start2 start2 :end2 end2))

(define-assertion assert-string-match (text pattern)
  "Assert that TEXT matches globbing PATTERN."
  (string-match pattern text))


;;;;
;;;; List Assertions
;;;;

(define-assertion assert-list-equal (list1 list2 &key (test #'eql))
  "Assert that LIST1 and LIST2 are equal.
Lists are equal if they have the same length and have equal elements at each
index. The equality predicate used to compare elements is either EQL or the predicate
provided by the :TEST keyword argument."
  :report
  (lambda (stream)
    (if (not (= (length list1) (length list2)))
        (format stream
                "~%~%The LIST1 and LIST2 have length ~A and ~A respectively."
                (length list1) (length list2))
        (loop :with difference-seen = nil
              :for item1 :in list1
              :for item2 :in list2
              :for index = 0 :then (1+ index)
              :unless (funcall test item1 item2)
              :do (progn
                    (unless difference-seen
                      (format stream "~%~%")
                      (setf difference-seen t))
                    (format stream
			    "~&  LIST1 and LIST2 differ at index ~A where they feature items ~S and ~S."
			    index (elt list1 index) (elt list2 index))))))
  (loop :for answer = (= (length list1) (length list2)) :then (funcall test item1 item2)
	:for item1 :in list1
	:for item2 :in list2
	:while answer
	:finally (return answer)))

;;;;
;;;; List as Set Assertions
;;;;

(define-assertion assert-subsetp (list1 list2 &key key (test #'eql))
  "Assert that the set represented by LIST1 is a subset of LIST2."
  :report
  (lambda (stream)
    (format stream "~%~%The items with keys:~%~%  ~{~S~^ ~}~&~%are in LIST1 but not in LIST2."
            (set-difference list1 list2 :key key :test test)))
  (subsetp list1 list2 :key key :test test))

(define-assertion assert-set-equal (list1 list2 &key key (test #'eql))
  "Assert that LIST1 denotes the same set as LIST2."
  :report
  (lambda (stream)
    (unless (subsetp list1 list2 :key key :test test)
      (format stream "~%~%The items with keys:~%~%  ~{~S~^ ~}~&~%are in LIST1 but not in LIST2."
              (set-difference list1 list2 :key key :test test)))
    (unless (subsetp list2 list1 :key key :test test)
      (format stream "~%~%The items with keys:~%~%  ~{~S~^ ~}~&~%are in LIST2 but not in LIST1."
              (set-difference list2 list1 :key key :test test))))
  (and (subsetp list1 list2 :key key :test test)
       (subsetp list2 list1 :key key :test test)))


;;;;
;;;; Vector Assertions
;;;;

(define-assertion assert-vector-equal (vector1 vector2 &key (test #'eql))
  "Assert that VECTOR1 and VECTOR2 are equal.
Vectors are equal if they have the same length and have equal elements at each
index. The equality predicate used to compare elements is either EQL or the predicate
provided by the :TEST keyword argument."
  :report
  (lambda (stream)
    (if (not (= (length vector1) (length vector2)))
        (format stream
                "~%~%The VECTOR1 and VECTOR2 have length ~A and ~A respectively."
                (length vector1) (length vector2))
        (loop :with difference-seen = nil
              :for item1 :across vector1
              :for item2 :across vector2
              :for index = 0 :then (1+ index)
              :unless (funcall test item1 item2)
              :do (progn
                    (unless difference-seen
                      (format stream "~%~%")
                      (setf difference-seen t))
                    (format stream
			    "~&  VECTOR1 and VECTOR2 differ at index ~A where they feature items ~S and ~S."
			    index (aref vector1 index) (aref vector2 index))))))
  (loop :for answer = (= (length vector1) (length vector2)) :then (funcall test item1 item2)
        :for item1 :across vector1
        :for item2 :across vector2
        :while answer
        :finally (return answer)))


;;;;
;;;; Float Assertions
;;;;

(defparameter *single-float-precision*
  (float-precision 1.0)
  "The precision used to compare of single precision floats.
This number can be understood as the number of matching digits in the binary representation
of the fractional part of float numbers, yet distinct tests interpret this value differently.")

(defparameter *double-float-precision*
  (float-precision 1.0d0)
  "The precision used to compare of double precision floats.
This number can be understood as the number of matching digits in the binary representation
of the fractional part of float numbers, yet distinct tests interpret this value differently.")

(defmacro float-comparison-threshold (float-type binop k u v)
  `(let (float-precision float-unit _ eu ev)
     (declare (ignorable _))
     (ecase ,float-type
       (single-float
	(setf float-precision *single-float-precision*)
	(setf float-unit 1.0))
       (double-float
	(setf float-precision *double-float-precision*)
	(setf float-unit 1.0d0)))
     (setf (values _ eu _) (decode-float ,u)
           (values _ ev _) (decode-float ,v))
     (scale-float float-unit (+ (- ,k float-precision 2) (,binop eu ev)))))

(define-assertion assert-float-is-approximately-equal (float1 float2  &key (inaccuracy 0) (float-type 'single-float))
  "Assert that FLOAT1 is approximately equal to FLOAT2.
This means that FLOAT1 and FLOAT2 are in a neighbourhood whose size is based
on the magnitude orders of FLOAT1 and FLOAT2 and the floating point precision.

A specific FLOAT-TYPE of 'SINGLE-FLOAT or 'DOUBLE-FLOAT can be explicitly supplied."
  :report
  (lambda (stream)
    (format stream
	    "~%~%The neighbourhood used to compare approximate equality of ~A

  ~A  and  ~A

with an inaccuracy of ~A has size ~A."
            float-type
	    float1 float2
	    inaccuracy (float-comparison-threshold float-type max inaccuracy float1 float2)))
  (<= (abs (- float1 float2)) (float-comparison-threshold float-type max inaccuracy float1 float2)))

(define-assertion assert-float-is-essentially-equal (float1 float2 &key (inaccuracy 0) (float-type 'single-float))
  "Asssert that FLOAT1 is essentially equal to FLOAT2.
This means that FLOAT1 and FLOAT2 are in a neighbourhood whose size is based
on the magnitude orders of FLOAT1 and FLOAT2 and the floating point precision.

A specific FLOAT-TYPE of 'SINGLE-FLOAT or 'DOUBLE-FLOAT can be explicitly supplied."
  :report
  (lambda (stream)
    (format stream
	    "~%~%The neighbourhood used to compare essential equality of ~A

  ~A  and  ~A

with an inaccuracy of ~A has size ~A."
            float-type
	    float1 float2
	    inaccuracy (float-comparison-threshold float-type max inaccuracy float1 float2)))
  (<= (abs (- float1 float2)) (float-comparison-threshold float-type min inaccuracy float1 float2)))

(define-assertion assert-float-is-definitely-less-than (float1 float2 &key (inaccuracy 0) (float-type 'single-float))
  "Assert that FLOAT1 is definetely less than FLOAT2
This means that FLOAT2 is greater than FLOAT1 and not in a neighbourhood of FLOAT1
whose diameter is controlled by the INACCURACY, the magnitude orders of FLOAT1 and
FLOAT2 and the floating point precision.

A specific FLOAT-TYPE of 'SINGLE-FLOAT or 'DOUBLE-FLOAT can be explicitly supplied."
  :report
  (lambda (stream)
    (format stream
	    "~%~%The neighbourhood used to compare definitive ordering of ~A

  ~A  and  ~A

with an inaccuracy of ~A has size ~A."
            float-type
            float1 float2
	    inaccuracy (float-comparison-threshold float-type max inaccuracy float1 float2)))
  (> (- float2 float1) (float-comparison-threshold float-type max inaccuracy float1 float2)))


(define-assertion assert-float-is-definitely-greater-than (float1 float2 &key (inaccuracy 0) (float-type 'single-float))
  "Assert that FLOAT1 is defintely greater than FLOAT2.
This means that FLOAT1 is greater than FLOAT2 and not in a neighbourhood of FLOAT2
whose diameter is controlled by the INACCURACY, the magnitude orders of FLOAT1 and
FLOAT2 and the floating point precision.

A specific FLOAT-TYPE of 'SINGLE-FLOAT or 'DOUBLE-FLOAT can be explicitly supplied."
  :report
  (lambda (stream)
    (format stream
	    "~%~%The neighbourhood used to compare definitive ordering of ~A

  ~A  and  ~A

with an inaccuracy of ~A has size ~A."
            float-type
            float1 float2
	    inaccuracy (float-comparison-threshold float-type max inaccuracy float2 float1)))
  (> (- float1 float2) (float-comparison-threshold float-type max inaccuracy float2 float1)))

;;;; End of file `assertion.lisp'
